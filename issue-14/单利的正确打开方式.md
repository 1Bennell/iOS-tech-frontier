单例的正确打开方式
---
> * 原文链接 : [The Right Way to Write a Singleton](http://krakendev.io/blog/the-right-way-to-write-a-singleton?utm_campaign=This%2BWeek%2Bin%2BSwift&utm_medium=web&utm_source=This_Week_in_Swift_45)
* 原文作者 : [Hector Matos](http://krakendev.io/?author=5592eaffe4b08369d0205792)
* 译文出自 :  [开发技术前线 www.devtf.cn](http://www.devtf.cn)
* 译者 : [Gottabe](https://github.com/Gottabe) 
* 校对者: 
* 状态 : 完成

Even though I've written about the woes of managing state in my previous post, sometimes there's just no way we can avoid it. One example of managing state is something we're all quite acquainted with - The Singleton. The problem we find in Swift is that there are SEVERAL ways of implementing them. But which way is the right way? In this post I'm going to show you the history of the singleton and then show you the right way to implement the singleton in Swift.

尽管在我之前的博文里我就写过关于管理状态的那些坑，但是有时候我们就是无法避免它们。其中一类管理状态的方式我们耳熟能详 － 单例。但是在Swift中有好几种不同的方式来实现一个单例。到底哪一个才是正确的方式呢？在这边博客里，我将和你好好聊聊单例的历史和在Swift中单例正确的打开方式。

If you want to see the right way to implement the singleton pattern in Swift along with proof of it's "right-ness", you can scroll to the bottom of the post and see it there. :)

如果你想直接就看在Swift中如何正确地写出单例同时看到证明证明其“正确性”，你可以直接滚动到这篇博文的底部。：）

![](http://static1.squarespace.com/static/5592eb03e4b051859f0b377f/t/55a8b9c7e4b0581b80a3f50b/1437121043298/791010.jpg?format=300w)

#让我们先回忆一下
Swift is a natural evolution of Objective-C. In Objective-C, this is how we implemented the singleton:

Swfit源于Objective-C，高于Objective-C。在Objective-C中，我们是这样写单例的：

```objc
@interface Kraken : NSObject
@end

@implementation Kraken

+ (instancetype)sharedInstance {
	static Kraken *sharedInstance = nil;
	static dispatch_once_t onceToken;
	
	dispatch_once(&onceToken, ^{
		sharedInstance = [[Kraken alloc] init];
	});
	return sharedInstance;
}

@end
```
Now that we have that out of the way and we can see the basic structure of a singleton, let's lay out some rules so we understand what we're looking at:

当我们把它写出来之后，就能清楚的看到一个单例的架构，接下来我们把单例的规则理一理，以便更好的理解它： 

#单例的道义
There are essentially three things to remember about the Singleton:

关于单例，有三件事是你必须要记住的：

* A singleton has to be unique. This is why it's called a singleton. There can only be one instance for the lifetime of the application it exists in. Singletons exist to give us singular global state. Such examples are NSNotificationCenter, UIApplication, and NSUserDefaults.
* 单例必须是唯一的，所以它才被称为单例。在一个应用程序的生命周期里，有且只有一个实例存在。单例的存在给我们提供了一个唯一的全局状态。比如我们熟悉的NSNotification，UIApplication和NSUserDefaults都是单例。
* To maintain a singleton's unique-ness, the initializer of a singleton needs to be private. This helps to prevent other objects from creating instances of your singeton class themselves. Thank you to all who pointed that out to me :)
* 为了保持一个单例的唯一性，单例的构造器必须是私有的。这防治其他对象也能创建出单例类的实例。感谢所有帮我指出这点的人。
* Because of rule #1, in order to have only one instance throughout the lifetime of the application, that means it needs to be thread-safe. Concurrency really sucks when you think about it, but simply put, if a singleton is built incorrectly in code, you can have two threads try to initialize a singleton at the same time which can potentially give you two separate instances of a singleton. This means that it's possible for it to not be unique unless we make it thread-safe. This means we want to wrap the initialization in a dispatch_once GCD block to make sure the initialization code only runs once at runtime.
* 为了确保单例在应用程序的整个生命周期是唯一的，它就必须是线程安全的。当你一想到并发肯定一阵恶心，简单来说，如果你写单例的方式是错误的，就有可能会有两个线程尝试在同一时间初始化同一个单例，这样你就有潜在的风险得到两个不同的单例。这就意味着我们需要用GCD的dispatch_once来确保初始化单例的代码在运行时只执行一次。

Being unique and initializing in one place in an app is easy. The important thing to remember for the rest of this post is that a singleton fulfill the much-harder-to-see dispatch_once rule.

成为独一无二并只在一个地方做初始化并不难。这篇博客接下来要记住的内容就是要单例遵守了更难察觉的dispatch_once的规则。

#Swift单例
Since Swift 1.0, there have been several ways to create a singleton. These have been covered very extensively here, here, and here. But who likes clicking on links? SPOILER ALERT; There are four variations. Allow me to count the ways:

打从Swift 1.0开始，就有好几种创建单例的方法。在[这里](https://github.com/hpique/SwiftSingleton)，[这里](http://stackoverflow.com/questions/24024549/dispatch-once-singleton-model-in-swift)和[这里](https://developer.apple.com/swift/blog/?id=7)都有详细的说明。但谁有空点进去看呢？先来个剧透；一共有四种写法，请让我一一道来：

##最丑陋的写法（又名“为何你任然要坚持写Swift如果你死要用这种写法”的写法)

```swift
class TheOneAndOnlyKraken {
	class var sharedInstance: TheOneAndOnlyKraken {
		struct Static {
			static var onceToken: dispatch_once_t = 0
			static var instance: TheOneAndOnlyKraken? = nil
		}
		dispatch_once(&Static.onceToken) {
			static.instance = TheOneAndOnlyKraken()
		}
		return Static.instance!
	}
}
```
This way is a straight port of Objective-C's singleton implementation over to Swift. Ugly in my opinion because Swift was meant to be terse and expressive. Be better than the port guys. Be better. :P

这种写法其实就是把Objective-C中的写法照搬过来。我觉得奇丑无比因为Swift是一门更加简洁且表达力更强的语言。我们要做的比那些搬运工要好，要比他们好。:P

![](http://static1.squarespace.com/static/5592eb03e4b051859f0b377f/t/55a8b9a0e4b0581b80a3f4ae/1437120930876/?format=500w)

##结构体写法（又名“虽然我很老但是我很流行”写法）

```swift
class TheOneAndOnlyKraken {
	class var sharedInstance: TheOneAndOnlyKraken {
		struct Static {
			static let instance = TheOneAndOnlyKraken()
		}
		return Static.instance
	}
}
```
This way was how we had to do it in Swift 1.0 since classes still didn't support static class variables back then. Structs, however, did support them! Because of these restrictions on static variables, we were forced into a model that looked like this. It's better than the straight Objective-C port but still not good enough. Funnily enough, I still see this method of writing singletons several months after the release of Swift 1.2. But more on that later.

这个在Swift 1.0的时候必须得这么写，因为那个时候，类还不支持全局类变量。而结构体却支持。正因为在全局变量上的局限性，我们不得不这么写。这比直接把Objective-C那一套搬过来要好，但是还不够。好玩的是，在Swift 1.2发布后的几个月后，我还是经常能看到这些的写法，但这个以后再表。

##全局变量写法（又名“一句话写法”）

```swift
private let sharedKraken = TheOneAndOnlyKraken()
class TheOneAndOnlyKraken {
	class var sharedInstance: TheOneAndOnlyKraken {
		return sharedInstance
	}
}
```

As of Swift 1.2, we gained access control specifiers and the ability to have static class members. This meant that we didn't have to have a global variable clutter the global namespace and we could now prevent namespace collisions. This version is a lot Swiftier in my opinion.

在Swift 1.2之后，我们拥有了访问控制修饰词和可以使用全局类变量。这意味着我们不用整一个全局变量集群，也可以防止命名空间冲突。这才是我心目中Swift应该有的样子。

Now at this point, you may be asking why we don't see dispatch_once in our struct or global variable implementations. Well according to Apple, both of these methods fulfills the dispatch_once clause I outlined above. Here's a quote straight from their Swift Blog that proves that they are wrapped in dispatch_once blocks behind the scenes:

这会你可能会问我为什么没有在我们的结构体和全局变量实现中看不到dispatch_once。但其实Apple指出，这两个方法同时满足了我上面提到的dispatch_once条文。下面就截取他们写的[Swift Blog](https://developer.apple.com/swift/blog/?id=7)中的一段话来证明他们以将dispatch_once整合进去了：

> "The lazy initializer for a global variable (also for static members of structs and enums) is run the first time that global is accessed, and is launched as `dispatch_once` to make sure that the initialization is atomic. This enables a cool way to use `dispatch_once` in your code: just declare a global variable with initializer and mark it private."
> -- Apple's Swfit Blog
> 
> "全局变量（静态成员变量和结构体以及枚举）的延迟构造器在其被第一次访问时会加载，并以`dispatch_once`的方式启动来确保初始化的原子性。这让你写代码时可以用一种很酷的方式来使用`dispatch_once`：直接用一个全局变量的构造器去做初始化并用private来修饰。“ -- Apple's Swift Blog

That's all Apple gave us as far as official documentation goes. But this meant that all we had proof for was global variables and static members of structs/enums! At that point, the only 100% safe bet backed by Apple docs was using a global variable to lazily wrap singleton initialization in a dispatch_once block. BUT WHAT ABOUT OUR STATIC CLASS VARIABLES?!?!?!?

就官方文献来看，Apple就给出这点说明。但这仅意味着对全局变量和结构体／枚举的静态成员我们是有证据的！目前来看，100%不会错的是用一个全局变量将一个单例的初始化包在一个隐含了dispatch_once的延迟构造器中。但是我们的全局类变量怎么办呢？！？！？！？

##正确的写法 又名“一行单例（已证明！）”

```swift
class TheOneAndOnlyKraken {
	static let sharedInstance = TheOneAndOnlyKraken()
}
```

![](http://static1.squarespace.com/static/5592eb03e4b051859f0b377f/t/55a8b8e5e4b0671daf047783/1437120742426/?format=500w)

So I've done a fair amount of research for this post. In fact, this post was inspired by a conversation we had at Capital One today due to the review of a PR that aimed at achieving proper singleton consistency in Swift across our app. We knew about this "right" method of writing singletons, but we had no proof to back up our reasoning other than postulation. Trying to back this method up without sufficient documentation was useless. It was my word against a lack of information on the internet/blogosphere. And everyone knows that if it isn't on the Internet it isn't true. This made me sad.

为了写这篇文章，我做了一番研究。事实上，之所以写这篇文章，是因为今日在Capital One的一次讨论，一位PR希望在我们所有的应用中用统一的方式来写单例。我们其实知道什么才是单例“正确”的书写方式，但是我们无法自证。如果不旁征博引来证明我们是正确的简直就是徒劳。这是我和缺乏信息的互联网／博文圈之间的较量。每个人都知道如果网上没写那就不是真的。这让我非常难过。

![](http://static1.squarespace.com/static/5592eb03e4b051859f0b377f/t/55a8b8bfe4b0671daf04772e/1437120704789/?format=500w)

I navigated to the far ends of the internets (AKA the 10th page of Google Search Results) and came up empty handed. Had no one posted proof of the one line singleton yet?! Maybe they have, but it was hard to find.

我的搜索达到了互联网的尽头（Google到了第10页）却啥也没得到。难道真就发表一行单例的证明吗？也许有人做了，就是没找到而已。

So I decided to do something about it and wrote up every way of initializing a singleton and inspected them at runtime using breakpoints. After analyzing each stack trace for any similarities I came across something interesting - PROOF!

所以我觉得我自己把所有的初始化构造器的方法都实现一遍，然后通过断点来检查他们。当分析完每个栈帧我所发现的相似点的时候，我终于发现期待已久的东西 － 证据！

Check it out, yo (Oh, and yay for class emojis!):

直接上图，对了（还有emoji类哦！）：

![](http://static1.squarespace.com/static/5592eb03e4b051859f0b377f/t/55a8b833e4b044eedeff6ac4/1437120566797/Screen+Shot+2015-07-16+at+4.56.38+PM.png?format=1000w)

使用全局单例

![](http://static1.squarespace.com/static/5592eb03e4b051859f0b377f/t/55a8b860e4b00cca65ee95a2/1437120615798/Using+the+One+Line+Singleton?format=1000w)

使用一行单例

The first image shows the stack trace of a global let instantiation. Outlined in red is the thing of interest here. Before the actual initialization of the Kraken singleton is a call trace labeled swift_once followed by a swift_once_block_invoke call. Since Apple said they lazily instantiate global variables in a dispatch_once block, we can safely assume this is what they meant.

第一张图显示了一个全局let实例化。红框表示的地方就是证据。在实际去实例化Karken单例之前，是先由一个*swfit_once*调用了一个*swift_once_block_invoke*。加上Apple说他们通过一个dispatch_once的block去延迟初始化一个全局变量，我们现在可以说这就证明了他们所说的。

Using this knowledge, I inspected the stack trace of our shiny & pretty one-line-singleton. As you can see with our second image, it's exactly the same! So there you have it! Proof that our one line singleton is proper. All is now right with the world. Also, now that this post is on the Internet, that MUST mean it's true!

带着这个信息，我又跟踪了我们既亮眼又简洁的一行单例。正如第二张图所以，两者简直一样！这就足以证明我们的一行单例实现是正确的。现在全世界都清净了。还有，既然这篇文章已经上了互联网，那么它*肯定*就是真理！

##不要忘了INIT的私有化！

As @davedelong, Frameworks Evangelist at Apple, graciously pointed out to me, you have to make sure that your inits are private. This makes sure your singletons are truly unique and prevents outside objects from creating their own instances of your class through virtue of access control. Since all objects come with a default public initializer in Swift, you need to override your init and make it private. This isn't too hard to do and still ensures our one line singleton is nice and pretty:

[@davedelong](https://twitter.com/davedelong)，Apple的架构师，非常含蓄的给我指出，你必须确保你的inits是私有的。只有这样才能确保你的单例是真正的独一无二，也能防止其他对象通过访问控制机制来创建他们自己的但是是你这个类的单例。因为在Swift中，所有对象的构造器默认都是public，你需要重写你的init让其成为私有的。这并不难实现而且也能确保我们的一行单例的优雅和简洁：

```swift
class TheOneAndOnlyKraken {
	static let sharedInstance = TheOneAndOnlyKraken()
	private init() {} // 这就阻止其他对象使用这个类的默认的'()'初始化方法
}
```

Doing this will makes sure that the compiler throws this error when any class attempts to initialize TheOneAndOnlyKraken using the () initializer:

这么做能确保任何类如果尝试通过()初始化方法来初始化TheOneAndOnlyKraken时，编译器都会报错：

![](http://static1.squarespace.com/static/5592eb03e4b051859f0b377f/t/55ae6ad6e4b035a17a870044/1437493975886/?format=1000w)

And there you have it! The perfect, one-line singleton.

你看！这就是完美的，一行实现单例。

#结论
Echoing jtbandes' excellent comment on the top rated answer to swift singletons on Stack Overflow, I simply could not find documentation anywhere that proved thread-safety by "virtue of let". I actually remember something of the sort said when I was at WWDC last year, but you can't expect readers or quick Googlers to stumble across that when trying to make sure this is the right way to write a singleton in Swift. Hopefully, this post can help someone out there understand why the one-line singleton in Swift is the way to go.

呼应一下[jtbandes](http://stackoverflow.com/users/23649/jtbandes)在[top rated answer to swift singletons on Stack Overflow](http://stackoverflow.com/a/24147830)上精彩的评论，我就无法找到关于使用'let'就能确保线程安全的任何文献。我其实依稀记得在去年的WWDC上有类似的这么一个说法，但你可不能指望读者或者googlers在尝试证明这就是在Swift中写单例的正确方法的时候就恰巧碰到那说法。不管怎么讲，我希望这篇博文能帮助一些人理解一行单例在Swift中是打开单例的正确方式。

基友们 Happy Coding!

![](http://static1.squarespace.com/static/5592eb03e4b051859f0b377f/t/55a8b7e7e4b0c3b7c348cc5e/1437120488261/?format=500w)